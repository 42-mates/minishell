executor():
1. if there are more than 1 command -> calls execute_multi()
2. if there is 1 command or less:
    a. if no commands - calls set_redirection() which opens files if there are any redirections
    b. if 1 command and it is a builtin command - backup fds, redirect, execute builtin, restore fds
    c. if 1 command and it is not a builtin - calls execute_multi() to execute it in a child process

execute_nulti():
1. calls create_pipes() to create pipes according to the number of commands
2. iterates through the commands:
    a. forks a child process with its unique pid
    b. calls child_process():
        i. calls duplicate_fds() to redirect the file descriptors of the pipeline
        ii. calls set_redirection() to redirect to input/output/append file
        iii. checks command name:
            - if a builtin - executes builtin and exits child process
            - if an external command - calls execute_extern() - calls execve() to replace image with executable
    c. calls close_pipe_ends() to close pipe ends after command execution
    d. calls parent_process() - calls close_pipes() to close all open pipes and waits for all child processes to terminate



void	single_extern(t_command *cmd, t_shell *shell)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		err_msg(cmd->name, "failed to create child process", shell, 1);
		return;
	}
	else if (pid == 0)
	{
		char **envp = list_to_array(shell->env_vars);
		if (!envp)
		{
			perror("minishell: failed to convert environment variables");
			exit(EXIT_FAILURE);
		}
		if (set_redirection(cmd, shell) == -1)
			exit(shell->exit_status = 1);
		if (execve(cmd->name, cmd->args, envp) == -1) 
		{
			free_array(envp);
			perror("minishell: execve:");
			exit(shell->exit_status = errno);
		}
	}
	waitpid(pid, NULL, 0);
}